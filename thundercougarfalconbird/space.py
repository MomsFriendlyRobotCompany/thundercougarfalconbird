# -*- coding: utf-8 -*-
##############################################
# The MIT License (MIT)
# Copyright (c) 2022 Kevin Walchko
# see LICENSE for full details
##############################################
from dataclasses import dataclass
import numpy as np


class Satellite:
    """
    This is a simple stupid satellite model. The assumption is, the commanded
    torques are feed into the model. The torques could come from some external
    forces like thrusters.

    This model uses the Hamalton definition for quaternions: q(r,x,y,z)
    """
    J = np.diag([10,10,10])
    # Tlim = 0.9 # Nm
    # Hlim = 1.5 # Nms
    # dz = 0.05  # Nm

    def eqns(self, t, state, u):
        """
        state = [q(r,x,y,z), w]
            q: attitude of satellite
            w: rotation rate of satellite

        u = ext_torques(3)
        """

        J = self.J
        q = Quaternion(*state[:4])
        w = state[4:]
        qw = Quaternion(0, *w)

        ret = np.zeros(7)
        ret[:4] = 0.5*q*qw
        ret[4:] = np.linalg.inv(J) @ (u - np.cross(w, J @ w))
        return ret


class SatelliteWithWheels(Satellite):
    """
    This is a slightly more realistic satellite model. In addition to
    external torques, it also accounts for momentum within the satellite
    generated by the wheels.

    This model uses the Hamalton definition for quaternions: q(r,x,y,z)
    """
    def eqns(self, t, state, u):
        """
        state = [q(r,x,y,z), w, h_w]
            q: attitude of satellite
            w: rotation rate of satellite
            h_w: momentum of wheels inside satellite

        u = torques(3)
        """
        J = self.J
        q = Quaternion(*state[:4])
        w = state[4:7]
        h = state[7:10]
        qw = Quaternion(0, *w)

        ret = np.zeros(10)
        ret[:4] = 0.5*q*qw
        ret[4:7] = np.linalg.inv(J) @ (u - np.cross(w, J @ w) - np.cross(w, h))
        ret[7:10] = -u

        return ret